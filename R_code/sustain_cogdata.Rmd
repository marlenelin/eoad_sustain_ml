---
title: "sustain_cogdata"
author: "Marlene Lin"
date: "2/10/2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# import
```{r}
library(car)
library(gridExtra)     # For handling grid-based plots
library(effects)
library(patchwork)
library(jsonlite)  # for saving to JSON
library(emmeans)
library(pastaPlot())
library(interactions)
library(readr)
library(dplyr)
library(tidyverse)
library(lme4)
library(lmerTest)
library(car)
library(ggplot2)
library(performance)
library(lubridate)
library(sjPlot)
library(ggpubr)  # For arranging plots
setwd("/Users/linlin/Desktop/brain stuff/data/")
```

# read
```{r readin} 
bldat <- read_csv("sustain_dat_baseline_filtered.csv") 
bldat_clean <- bldat %>% filter(dx == 'EOAD') %>% filter(subtype != 99)
bldat_clean$subtype <- as.factor(bldat_clean$subtype)
bldat_clean$stage <- as.numeric(bldat_clean$stage)
bldat_clean$PTGENDER <- as.factor(bldat_clean$PTGENDER)
dim(bldat_clean)

# Generate visualization plot
var_range <- read.csv("cognitive measures.csv")
```

# baseline
``` {r}  
# Define the list of variables to analyze
variables <- c('UDSBENTC', 'Line_orientation', 'Line_length', 'TRAILA', 'DIGFORCT', 
               'CRAFTURS', 'FTDREAAS', 'FTDSEMSU', 'FTDANATS', 'FTDRATIO', 'FTDVERBC', 
               'FTDNOUNC', 'FTDWORRC', 'FTDWORIC', 'FTDSEMMT', 'FTDSENAS', 'VEG', 
               'ANIMALS', 'MINTTOTS', 'MOCATOTS', 'CDRSB', 'NACCGDS', 'TOTAL13', 
               'MMSCORE', 'TRAILB', 'DIGBACCT', 'UDSVERLC', 'UDSVERFC', 'digittotal', 
               'Match', 'Flanker',  'CRAFTDRE', 'UDSBENTD','AVDEL30MIN')
# 
# Using base R
bldat_clean$RAVLT_Forgetting <- bldat_clean$AVTOT5 - bldat_clean$AVDEL30MIN
bldat_clean$`Craft_Forgetting` <- bldat_clean$CRAFTURS - bldat_clean$CRAFTDRE
bldat_clean$`Benson_Forgetting` <- bldat_clean$UDSBENTC - bldat_clean$UDSBENTD

variables <-c("RAVLT_Forgetting","Craft_Forgetting","Benson_Forgetting")

# Loop through each variable
for (var in variables) {
  print(var)
  # Create a directory for each variable
  dir_name <- paste0("Results_", var)
  if (!dir.exists(dir_name)) {
    dir.create(dir_name)
  }
  
  # save baseline model output
  formula <- as.formula(paste(var, "~ subtype * stage + PTEDUCAT + PTGENDER + Centiloid + Age"))
  model <- lm(formula, data = bldat_clean)
  ss <- summary(model)
  summary_output <- capture.output(ss)
  writeLines(summary_output, file.path(dir_name, paste0(var, "_model_summary.txt")))
  s1_slope <- round(ss$coefficients['stage','Estimate'],2)
  s2_slope <- s1_slope + round(ss$coefficients['subtype2:stage','Estimate'],2)
  s3_slope <- s1_slope + round(ss$coefficients['subtype3:stage','Estimate'],2)
  aov_ss <- summary(aov(model) )
  inter_p <- round(aov_ss[[1]]["subtype:stage", "Pr(>F)"],3)
  if (inter_p < 0.001)
    inter_p = '***'
  # save slope compare
  trends <- capture.output(emtrends(model, pairwise~subtype,var='stage'))
  writeLines(trends, file.path(dir_name, paste0(var, "_slope_compare.txt")))
  # save faceted plot
  plot_obj <- interact_plot(model, pred = "stage", modx = "subtype", plot.points = TRUE, int.width = 0.95, interval = TRUE,facet.modx=TRUE,linearity.check = TRUE)
  ggsave(file.path(dir_name, paste0(var, "_facet_baseline.png")), plot = plot_obj, width = 10, height = 6, dpi = 300)
  
  # Generate simple slopes analysis and save it
  simple_slopes_output <- capture.output(sim_slopes(model, pred = "stage", modx = "subtype"))
  writeLines(simple_slopes_output, file.path(dir_name, paste0(var, "_simple_slopes.txt")))

  # spaghettic plot
  # Create new data for prediction
newdata <- expand.grid(
  stage = seq(min(bldat_clean$stage), max(bldat_clean$stage), length.out = 100),
  subtype = unique(bldat_clean$subtype),
  PTEDUCAT = mean(bldat_clean$PTEDUCAT, na.rm = TRUE),
  Centiloid = mean(bldat_clean$Centiloid, na.rm = TRUE),
  Age = mean(bldat_clean$Age, na.rm = TRUE),
  PTGENDER = "Male"  # Set reference gender
)

  # Get predicted values with confidence intervals
  predictions <- as.data.frame(predict(model, newdata = newdata, interval = "confidence"))
  newdata <- cbind(newdata, predictions)
  # Get predicted values with confidence intervals
   
  # Get min and max for the variable
  var_limits <- var_range %>% filter(related_var == var)
  min_value <- var_limits$min
  max_value <- var_limits$max
  # Generate visualization plot with fixed y-axis range
  visualization_plot <- ggplot() +
    geom_point(data = bldat_clean, aes(x = stage, y = get(var)), color = "grey40", alpha = 0.6, size = 2) +
    geom_ribbon(data = newdata, aes(x = stage, ymin = lwr, ymax = upr, fill = subtype), alpha = 0.2, color = NA) +
    geom_line(data = newdata, aes(x = stage, y = fit, color = subtype), size = 1.2) +
    labs(
      x = "Stage", y = var, color = "Subtype", fill = "Subtype",title='Baseline'
    ) +
    # Blue 1: "#1f449c",  # Dark Blue # Green 2: "#32ABA6",  # Green# Red  3: "#f05039",  # Red
  #  scale_color_manual(values = c("dark blue", "dark green", "dark red")) +
  #  scale_fill_manual(values = c("dark blue", "dark green", "dark red")) +
    scale_color_manual(values = c("#1f449c", "#32ABA6", "#f05039")) +
  scale_fill_manual(values = c("#1f449c", "#32ABA6", "#f05039"))+

   # annotate("text", x = -Inf, y = -Inf, label = paste('inter. p: ',inter_p), 
   #          hjust = -0.8, vjust = -0.5, color = "black", size = 10, fontface = "bold") +
  #  annotate("text", x = -Inf, y = -Inf, label = paste('S3: ',s3_slope), 
  #           hjust = -0.1, vjust = -0.5, color = "dark red", size = 10, fontface = "bold") +
  #  annotate("text", x = -Inf, y = -Inf, label = paste('S2: ',s2_slope), 
  #           hjust = -0.1, vjust = -2, color = "dark green", size = 10, fontface = "bold") + 
  #  annotate("text", x = -Inf, y = -Inf, label = paste('S1: ',s1_slope), 
  #           hjust = -0.1, vjust = -3.5, color = "dark blue", size = 10, fontface = "bold") +
    #theme_minimal(base_size = 15) +
    theme(
      
       axis.text.x = element_text(size=15),
      axis.text.y = element_text(size=15),
      panel.background = element_blank(),
      plot.background = element_rect(fill = "white", color = NA),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      legend.position='none',
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      axis.line = element_line(color = "black", size = 1),
      axis.ticks = element_line(color = "black", size = 1)
    ) +
   #scale_y_continuous(limits =c(min_value, max_value),expand = c(0,0))
   coord_cartesian(ylim = c(min_value, max_value))  # Apply fixed y-axis limits 
  # Save visualization plot
  ggsave(file.path(dir_name, paste0(var, "_visualization_plot_unannotated.png")), plot = visualization_plot, width = 8, height = 6, dpi = 300,bg='#ffffff')

  print(paste("Analysis completed for:", var))
}

```


# baseline jitter
```{R}
# Define the list of variables to analyze
variables <- c('MINTTOTS', 'CDRSB', 'DIGFORCT',
               'MMSCORE', 'TRAILB', 'UDSBENTC')

# Loop through each variable
for (var in variables) {
  print(var)
  # Create a directory for each variable
  dir_name <- paste0("Results_", var)
  if (!dir.exists(dir_name)) {
    dir.create(dir_name)
  }
  
  # save baseline model output
  formula <- as.formula(paste(var, "~ subtype * stage + PTEDUCAT + PTGENDER + Centiloid + Age"))
  model <- lm(formula, data = bldat_clean)

  # Create new data for prediction
  newdata <- expand.grid(
    stage = seq(min(bldat_clean$stage), max(bldat_clean$stage), length.out = 100),
    subtype = unique(bldat_clean$subtype),
    PTEDUCAT = mean(bldat_clean$PTEDUCAT, na.rm = TRUE),
    Centiloid = mean(bldat_clean$Centiloid, na.rm = TRUE),
    Age = mean(bldat_clean$Age, na.rm = TRUE),
    PTGENDER = "Male"  # Set reference gender
  )

  # Get predicted values with confidence intervals
  predictions <- as.data.frame(predict(model, newdata = newdata, interval = "confidence"))
  newdata <- cbind(newdata, predictions)

  # Get min and max for the variable
  var_limits <- var_range %>% filter(related_var == var)
  min_value <- var_limits$min
  max_value <- var_limits$max

  # Generate visualization plot with horizontal jitter
  visualization_plot <- ggplot() +
    geom_jitter(data = bldat_clean, 
                aes(x = stage, y = get(var)), 
                color = "grey40", alpha = 0.6, size = 2, 
                width = 0.6, height = 0.2) +  # jitter only horizontally
    geom_ribbon(data = newdata, aes(x = stage, ymin = lwr, ymax = upr, fill = subtype), 
                alpha = 0.2, color = NA) +
    geom_line(data = newdata, aes(x = stage, y = fit, color = subtype), 
              size = 1.2) +
    labs(
      x = "Stage", y = var, color = "Subtype", fill = "Subtype", title = 'Baseline'
    ) +
    scale_color_manual(values = c("#1f449c", "#32ABA6", "#f05039")) +
    scale_fill_manual(values = c("#1f449c", "#32ABA6", "#f05039")) +
    theme(
      axis.text.x = element_text(size = 15),
      axis.text.y = element_text(size = 15),
      panel.background = element_blank(),
      plot.background = element_rect(fill = "white", color = NA),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      legend.position = 'none',
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      axis.line = element_line(color = "black", size = 1),
      axis.ticks = element_line(color = "black", size = 1)
    ) +
    coord_cartesian(ylim = c(min_value, max_value))

  # Save the visualization plot
  ggsave(file.path(dir_name, paste0(var, "_visualization_plot_unannotated_jitter.png")), 
         plot = visualization_plot, width = 8, height = 6, dpi = 300, bg = '#ffffff')

  print(paste("Analysis completed for:", var))
}

```

# longitudinal 
```{R}  
long <- read.csv('combined_exclude_long_forR_longi.csv')
var_list <- c('UDSBENTC','TRAILA','DIGFORCT','MINTTOTS','Semantic_fluency','MOCATOTS','CDRSB','ANIMALS','MOCATOTS','TRAILB','DIGBACCT','Phonemic_fluency','AVDEL30MIN','CRAFTDRE','UDSBENTD' )
#var_list <- c('UDSBENTC')
# Loop through each variable
subject_counts <- list()
for (var_name in var_list) {
  var_file <- paste0(var_name, ".csv")  # Assign the file path
  print(var_name)  # Print progress
  df <- read.csv(var_file)

  # Filter EOAD patients and keep subjects with at least two records
  df <- df %>%
    filter(subj %in% long$subj) %>%
    filter(dx == "EOAD" & subtype != 99 & !is.na(.data[[var_name]])) %>% # & .data[[var_name]] > 0
    group_by(subj) %>%
    filter(n() > 1) %>%
    ungroup()
  print(summary(df[[var_name]]))
  df$subtype <- as.factor(df$subtype)
  df$PTGENDER <- as.factor(df$PTGENDER)
  
  # Define and fit the longitudinal model
  longitudinal_model <- lmer(as.formula(paste(var_name, "~ subtype * time_yr + Centiloid + PTGENDER + Age + PTEDUCAT + (1 + time_yr | subj)")), data = df, REML = FALSE)

  # Create results directory
  results_folder <- paste0("results_", var_name)
  dir.create(results_folder, showWarnings = FALSE)

  # Save model summary
  sink(file.path(results_folder, paste0(var_name, "_longitudinal_model.txt")))
  print(summary(longitudinal_model))
  sink()
  ss<-summary(longitudinal_model)
  s1_slope <- round(ss$coefficients['time_yr','Estimate'],2)
  s2_slope <- s1_slope + round(ss$coefficients['subtype2:time_yr','Estimate'],2)
  s3_slope <- s1_slope + round(ss$coefficients['subtype3:time_yr','Estimate'],2)
  aov_ss <- Anova(longitudinal_model)
  anova_output <- capture.output(print(aov_ss))
  writeLines(anova_output, file.path(results_folder, paste0(var_name, "anova_long.txt")))
  # trend compare
  trends <- capture.output(emtrends(longitudinal_model, pairwise~subtype,var='time_yr'))
  writeLines(trends, file.path(results_folder, paste0(var_name, "_slope_compare_longitudinal.txt")))
  # omnibus p
  inter_p <- round(aov_ss["subtype:time_y", "Pr(>Chisq)"],3)
  if (inter_p < 0.001)
    inter_p = '***'
  # slope emmtrend comparion
  trends <- capture.output(emtrends(longitudinal_model, pairwise~subtype,var='time_yr'))
  writeLines(trends, file.path(results_folder, paste0(var, "_slope_compare_longitudinal.txt")))
  # Generate simple slopes analysis and save it
  simple_slopes_output <- capture.output(sim_slopes(longitudinal_model, pred = "time_yr", modx = "subtype"))
  writeLines(simple_slopes_output, file.path(results_folder, paste0(var, "_simple_slopes_longitudinal.txt")))

  # Generate new data for predictions
  newdata <- expand.grid(
    time_yr = seq(min(df$time_yr, na.rm = TRUE), max(df$time_yr, na.rm = TRUE), length.out = 100),
    subtype = unique(df$subtype),
    Centiloid = mean(df$Centiloid, na.rm = TRUE),
    PTGENDER = "Male",  # Reference gender
    Age = mean(df$Age, na.rm = TRUE),
    PTEDUCAT = mean(df$PTEDUCAT, na.rm = TRUE)
  )

  # Generate predictions
  predictions <- predict(longitudinal_model, newdata = newdata, re.form = NA, se.fit = TRUE)
  newdata$fit <- predictions$fit
  newdata$lwr <- newdata$fit - 1.96 * predictions$se.fit
  newdata$upr <- newdata$fit + 1.96 * predictions$se.fit

  # Plot results
  # Load variable range data
  y_min <- var_range$min[var_range$related_var == var_name]
  y_max <- var_range$max[var_range$related_var == var_name]

  # Ensure valid y-axis limits
  if (length(y_min) == 0 | length(y_max) == 0) {
    warning(paste("No range found for", var_name, "- Skipping y-axis adjustment"))
    next
  }
  # save subject count 
  n_sub <- length(unique(df$subj[!is.na(df[[var_name]])]))
  subject_counts[[var_name]] <- n_sub
   p <- ggplot() + 
    geom_line(data = df, aes(x = time_yr, y = .data[[var_name]], group = subj), color = "grey80", size = 0.4) +
    geom_ribbon(data = newdata, aes(x = time_yr, ymin = lwr, ymax = upr, fill = subtype), alpha = 0.2) +
    geom_line(data = newdata, aes(x = time_yr, y = fit, color = subtype), size = 1.2) +
    labs(
      x = "Years from Baseline",
      y = paste("Predicted", var_name),
      title = paste0(var_name, " (n=", n_sub, 
               ", records=", sum(!is.na(df[[var_name]])), ")"),
      color = "Subtype",
      fill = "Subtype"
    ) +
  #  scale_color_manual(values = c("dark blue", "dark green", "dark red")) +
  #  scale_fill_manual(values = c("dark blue", "dark green", "dark red")) +
         scale_color_manual(values = c("#1f449c", "#32ABA6", "#f05039")) +
  scale_fill_manual(values = c("#1f449c", "#32ABA6", "#f05039"))+

   # annotate("text", x = -Inf, y = -Inf, label = paste('S3: ',s3_slope), 
   #          hjust = -0.1, vjust = -0.5, color = "dark red", size = 10, fontface = "bold") +
  #  annotate("text", x = -Inf, y = -Inf, label = paste('S2: ',s2_slope), 
  #           hjust = -0.1, vjust = -2, color = "dark green", size = 10, fontface = "bold") + 
  #  annotate("text", x = -Inf, y = -Inf, label = paste('S1: ',s1_slope), 
   #          hjust = -0.1, vjust = -3.5, color = "dark blue", size = 10, fontface = "bold") +
  #  annotate("text", x = -Inf, y = -Inf, label = paste('inter. p: ',inter_p), 
  #           hjust = -0.8, vjust = -0.5, color = "black", size = 10, fontface = "bold") +
    theme(
       axis.text.x = element_text(size=15),
      axis.text.y = element_text(size=15),
      panel.background = element_blank(),
      plot.background = element_rect(fill = "white", color = NA),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      legend.position='none',
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      axis.line = element_line(color = "black", size = 1),
      axis.ticks = element_line(color = "black", size = 1)
     
    ) +
     coord_cartesian(ylim = c(y_min, y_max))  # Apply fixed y-axis limits 
  
  # scale_y_continuous(limits =c(y_min,y_max),expand = c(0,0))
  # Save plot
  ggsave(file.path(results_folder, paste0(var_name, "_longitudinal_plot_unannotated.png")), plot = p, width = 8, height = 6, dpi = 300,bg='#ffffff')
  
  # facet
  # Create a list to store plots
 # Create a list to store plots
plot_list <- list()

# Define subtype colors
subtype_colors <- c("1" = "dark blue", "2" = "dark green", "3" = "dark red")
 
unique_subtypes <- c(1, 2, 3)
for (i in seq_along(unique_subtypes)) {
  sub <- unique_subtypes[i]
  df_sub <- df %>% filter(subtype == sub)
  newdata_sub <- newdata %>% filter(subtype == sub)

  p_sub <- ggplot() + 
    geom_line(data = df_sub, aes(x = time_yr, y = .data[[var_name]], group = subj), color = "grey80", size = 0.4) +
    geom_ribbon(data = newdata_sub, aes(x = time_yr, ymin = lwr, ymax = upr, fill = subtype), alpha = 0.2) +
    geom_line(data = newdata_sub, aes(x = time_yr, y = fit), color = subtype_colors[as.character(sub)], size = 1.2) +
    labs(
      x = "Years from Baseline",
      title = paste0("Subtype ", sub)
    ) +
    scale_fill_manual(values = subtype_colors) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 15),
      axis.text.y = if (i == 1) element_text(size = 15) else element_blank(),  # Remove y-axis text except for the first plot
      axis.title.y = if (i == 1) element_text(size = 15) else element_blank(),  # Remove y-axis label except for the first plot
      axis.ticks.y = if (i == 1) element_line(color = "black", size = 1) else element_blank(),  # Remove y-axis ticks except for the first plot
      plot.background = element_rect(fill = "white", color = NA),
      legend.position = "none",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.line = element_line(color = "black", size = 1),
      axis.ticks = element_line(color = "black", size = 1)
    ) +
    coord_cartesian(ylim = c(y_min, y_max))  # Keep same y-axis limits
  
  plot_list[[as.character(sub)]] <- p_sub
}

# Combine plots in one row using patchwork
final_plot <- plot_list[[1]] + plot_list[[2]] + plot_list[[3]] + plot_layout(nrow = 1)

# Save the final combined image
ggsave(file.path(results_folder, paste0(var_name, "_longitudinal_facet.png")), 
       plot = final_plot, width = 10, height = 5, dpi = 300, bg = '#ffffff')

cat("Saved improved combined facet plot for:", var_name, "\n")}

cat("All models processed successfully!\n") 
write_json(subject_counts, "subject_counts_long.json", pretty = TRUE)

```

## diagnostic
```{r}
#plot(longitudinal_model)
#resid_panel(longidutinal_model, smoother = TRUE, qqbands = TRUE)
check_model(longitudinal_model)
```

# missingness ï¼ˆbaseline)
## missingness heatmap (by missing count)
```{r} 

# Ensure a subject identifier exists
bldat_clean <- bldat_clean %>%
  mutate(subject_id = row_number())  # Create a subject ID if missing

# Define the list of variables
variables <- c('MOCATOTS','MMSCORE','TOTAL13', 'CDRSB', 'NACCGDS',
               'digittotal',  'avdel30min', 'avdeltot',
               'UDSBENTC','UDSBENTD', 'UDSVERLC', 'UDSVERFC',
               'CRAFTURS', 'CRAFTDRE','VEG',  'ANIMALS','TRAILA', 'TRAILB',
               'DIGFORCT',  'DIGBACCT', 'MINTTOTS', 
               'Line_orientation', 'Line_length','Match', 'Flanker', 
               'FTDREAAS', 'FTDSEMSU', 'FTDANATS', 'FTDRATIO', 'FTDVERBC', 
               'FTDNOUNC', 'FTDWORRC', 'FTDWORIC', 'FTDSEMMT', 'FTDSENAS')

# Create binary missingness indicators
bldat_clean_long <- bldat_clean %>%
  pivot_longer(cols = all_of(variables), 
               names_to = "variable", 
               values_to = "value") %>%
  mutate(missing = ifelse(is.na(value), 1, 0))  # 1 = missing, 0 = not missing

# Compute total missing per variable for ordering
missing_summary <- bldat_clean_long %>%
  group_by(variable) %>%
  summarise(total_missing = sum(missing), .groups = "drop") %>%
  arrange(desc(total_missing))

# Keep variable order as originally computed
bldat_clean_long$variable <- factor(bldat_clean_long$variable, levels = missing_summary$variable)

# Compute total missing per subject within each subtype
subject_missing <- bldat_clean_long %>%
  group_by(subtype, subject_id) %>%
  summarise(total_missing = sum(missing), .groups = "drop")

# Merge back to long data
bldat_clean_long <- bldat_clean_long %>%
  left_join(subject_missing, by = c("subtype", "subject_id"))

# Ensure subjects are ordered within each subtype by total missingness
bldat_clean_long <- bldat_clean_long %>%
  arrange(subtype, desc(total_missing)) %>%
  mutate(subject_id = factor(subject_id, levels = unique(subject_id)))  # Ensure correct order

# Create the heatmap-style facet plot
ggplot(bldat_clean_long, aes(x = subject_id, y = variable, fill = factor(missing))) +
  geom_tile() +
  facet_wrap(~ subtype, scales = "free_x") +  # Facet by subtype
  scale_fill_manual(values = c("white", "red"), labels = c("Not Missing", "Missing")) +
  labs(title = "Missingness Heatmap by Subtype",
       x = "Subjects (Ordered by Missing Count)",
       y = "Variables",
       fill = "Missingness") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  # Hide subject labels for clarity
        axis.ticks.x = element_blank(),
        strip.text = element_text(size = 10),
        plot.title = element_text(hjust = 0.5))

```

 

## line chart for missingness
```{R}
# Define the list of variables to visualize
variables <- c( 'Line_orientation', 'Line_length', 'Match', 'Flanker','TRAILB',
                'FTDREAAS', 'FTDSEMSU', 'FTDANATS', 'FTDRATIO', 'FTDVERBC', 
               'FTDNOUNC', 'FTDWORRC', 'FTDWORIC', 'FTDSEMMT', 'FTDSENAS')
# Compute missing count per variable and subtype
missing_summary <- bldat_clean_long %>%
  filter(variable %in% variables) %>%  # <-- Filter to keep only selected variables
  group_by(variable, subtype) %>%
  summarise(missing_count = sum(missing), .groups = "drop")

# Compute total missing per variable for ordering
total_missing_summary <- missing_summary %>%
  group_by(variable) %>%
  summarise(total_missing = sum(missing_count), .groups = "drop") %>%
  arrange(desc(total_missing))

# Order variables by total missingness
missing_summary$variable <- factor(missing_summary$variable, levels = total_missing_summary$variable)

# Define colors for subtypes
subtype_colors <- c("1" = "#1f77b4", "3" = "#d62728", "2" = "#2ca02c")

# Create horizontal bar chart
ggplot(missing_summary, aes(x = missing_count, y = variable, fill = factor(subtype))) +
  geom_bar(stat = "identity", position = "dodge") +  # Dodge bars to compare subtypes
  scale_fill_manual(values = subtype_colors) +
  labs(title = "Missing Count by Variable and Subtype",
       x = "Number of Missing Values",
       y = "Variables",
       fill = "Subtype") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

```
## subtype percentage 
```{r}
# Define the list of variables to visualize

# Compute total number of subjects per subtype
subtype_totals <- bldat_clean %>%
  group_by(subtype) %>%
  summarise(total_subjects = n(), .groups = "drop")

# Compute missing count per variable and subtype
missing_summary <- bldat_clean_long %>%
  filter(variable %in% variables) %>%  # <-- Filter to keep only selected variables
  group_by(variable, subtype) %>%
  summarise(missing_count = sum(missing), .groups = "drop") %>%
  left_join(subtype_totals, by = "subtype") %>%
  mutate(missing_percentage = (missing_count / total_subjects) * 100)

# Compute total missing per variable for ordering
total_missing_summary <- missing_summary %>%
  group_by(variable) %>%
  summarise(total_missing = sum(missing_percentage), .groups = "drop") %>%
  arrange(desc(total_missing))

# Order variables by total missingness
missing_summary$variable <- factor(missing_summary$variable, levels = total_missing_summary$variable)

# Define colors for subtypes
subtype_colors <- c("1" = "#1f77b4", "3" = "#d62728", "2" = "#2ca02c")

# Create horizontal bar chart with percentage
ggplot(missing_summary, aes(x = missing_percentage, y = variable, fill = factor(subtype))) +
  geom_bar(stat = "identity", position = "dodge") +  # Dodge bars to compare subtypes
  scale_fill_manual(values = subtype_colors) +
  labs(title = "Percentage of Missing Values by Variable and Subtype",
       x = "Percentage of Missing Values",
       y = "Variables",
       fill = "Subtype") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```
